## 动态规划
动态规划的目的：求值。
思考框架：
```text
明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。
```
### 凑零钱问题
```
给你k种面值的硬币，面值分别为c1, c2 ... ck，每种硬币的数量无限，再给一个总金额amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1
```
分析：
对选取的硬币，每次选取指定给定的硬币，则将问题分解为：
$dp[n] = min(1 + dp[n-coin],dp[i])$
$dp[i]=x$ 表示选取构成$i$元的最少硬币数为$x$.
```cpp
/**
 * @ Description  :
 * @ Version      : 1.0
 * @ Author       : koritafei(koritafei@gmail.com)
 * @ Date         : 2021-06-22 15:00:54
 * @ LastEditors  : koritafei(koritafei@gmail.com)
 * @ LastEditTime : 2021-06-22 15:11:47
 * @ FilePath     : /program/dp/coin.cc
 * @ Copyright (C) 2021 koritafei(koritafei@gmail.com). All rights reserved.
 * */

#include <iostream>
#include <vector>

int coin(std::vector<int> &coins, int amount) {
  std::vector<int> dp = std::vector<int>(amount + 1, amount + 1);
  dp[0]               = 0;
  for (int i = 0; i < dp.size(); i++) {
    for (auto c : coins) {
      if (i - c < 0) {
        continue;
      }
      dp[i] = std::min(dp[i], dp[i - c] + 1);
    }
  }

  return dp[amount] == amount + 1 ? -1 : dp[amount];
}

int main(int argc, char **argv) {
  std::vector<int> coins  = {1, 2, 5};
  int              amount = 11;
  std::cout << coin(coins, amount) << std::endl;
}
```
### 最优子结构详解
最优子结构：从最优子结构的结果推出更大规模问题的最优结果。
`dp`数组遍历方向：
> 1. 遍历过程中, 所需的状态必须是已经计算出来的；
> 2. 遍历终点必须是存储结果的位置。

### 状态压缩
状态压缩的核心思路：**将二维数组投影带一维数组中。**
